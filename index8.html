<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互動式網路圖</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 2px;
        }

        /* 新增主要內容容器 */
        .main-content {
            display: flex;
            height: 700px;
        }

        .controls {
            width: 350px;
            padding: 30px;
            background: rgba(102, 126, 234, 0.05);
            display: flex;
            flex-direction: column;
            gap: 30px;
            overflow-y: auto;
            border-right: 1px solid #e1e8ed;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 0.9rem;
        }

        .search-container {
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e1e8ed;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-suggestion {
            padding: 10px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .search-suggestion:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .search-suggestion:last-child {
            border-bottom: none;
        }

        .search-suggestion.highlighted {
            background-color: rgba(102, 126, 234, 0.15);
        }

        .search-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .search-btn {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-btn.focus {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .search-btn.clear {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e1e8ed;
        }

        .search-btn:hover {
            transform: translateY(-1px);
        }

        .multi-select-container {
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            background: white;
            max-height: 150px;
            overflow-y: auto;
            padding: 8px;
        }

        .multi-select-container:focus-within {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .checkbox-item:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            width: 14px;
            height: 14px;
        }

        .checkbox-item label {
            font-size: 12px;
            font-weight: normal;
            margin: 0;
            cursor: pointer;
            flex: 1;
        }

        button {
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        button:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .layout-toggle {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .layout-btn {
            width: 100%;
            padding: 10px;
            font-size: 12px;
        }

        .layout-btn.active {
            background: linear-gradient(45deg, #764ba2, #667eea);
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .zoom-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.1);
        }

        #network-container {
            flex: 1;
            height: 700px;
            position: relative;
            overflow: hidden;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            pointer-events: auto;
            z-index: 1000;
            max-width: 350px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .tooltip h4 {
            margin: 0 0 8px 0;
            color: #667eea;
            font-size: 14px;
        }

        .tooltip p {
            margin: 4px 0;
            line-height: 1.4;
        }

        .tooltip a {
            color: #87ceeb;
            text-decoration: none;
        }

        .tooltip a:hover {
            text-decoration: underline;
        }

        .tooltip .link-entry {
            border-left: 3px solid #667eea;
            padding-left: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 8px 0 8px 10px;
        }

        .tooltip .link-entry:not(:last-child) {
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            max-height: 400px;
            min-width: 180px;
            z-index: 1000;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            user-select: none;
        }

        .legend-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .legend-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: bold;
        }

        .legend-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .legend-content {
            padding: 20px;
            max-height: 350px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .legend.collapsed .legend-content {
            max-height: 0;
            padding: 0 20px;
            overflow: hidden;
        }

        .legend.collapsed .legend-toggle {
            transform: rotate(180deg);
        }

        .legend-section {
            margin-bottom: 15px;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section h5 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .legend-dashed {
            width: 20px;
            height: 2px;
            margin-right: 8px;
            flex-shrink: 0;
            background: repeating-linear-gradient(
                to right,
                #666 0px,
                #666 4px,
                transparent 4px,
                transparent 8px
            );
        }

        .node-text {
            font-size: 11px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            fill: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .link {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .link:hover {
            filter: brightness(1.3);
            stroke-width: 4px !important;
        }

        .link.multi-link {
            stroke-dasharray: 5,5;
            animation: dash 1s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            filter: brightness(1.2) drop-shadow(0 0 8px rgba(0,0,0,0.4));
        }

        .node.focused {
            filter: brightness(1.3) drop-shadow(0 0 15px rgba(102, 126, 234, 0.8));
            stroke: #667eea;
            stroke-width: 3px;
        }

        .node.dimmed {
            opacity: 0.3;
        }

        .link.dimmed {
            opacity: 0.2;
        }

        .node-text.dimmed {
            opacity: 0.3;
        }

        .select-all-btn {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e1e8ed;
            padding: 4px 8px;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: none;
            letter-spacing: normal;
        }

        .select-all-btn:hover {
            background: #e9ecef;
            transform: none;
            box-shadow: none;
        }

        .no-data-message {
            text-align: center;
            color: #666;
            font-size: 18px;
            padding: 50px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>網路關係圖</h1>
        </div>
    
    <div class="main-content">    
        <div class="controls">
            <div class="control-group">
                <label>搜尋節點</label>
                <div class="search-container">
                    <input type="text" class="search-input" id="nodeSearch" placeholder="輸入節點名稱..." autocomplete="off">
                    <div class="search-suggestions" id="searchSuggestions"></div>
                </div>
                <div class="search-buttons">
                    <button class="search-btn focus" onclick="focusOnSearchedNode()">聚焦</button>
                    <button class="search-btn clear" onclick="clearSearch()">清除</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>年份篩選</label>
                <button class="select-all-btn" onclick="toggleSelectAll('linkYear')">全選/取消全選</button>
                <div class="multi-select-container" id="linkYearSelect">
                </div>
            </div>
            
            <div class="control-group">
                <label>連結類型</label>
                <button class="select-all-btn" onclick="toggleSelectAll('linkType')">全選/取消全選</button>
                <div class="multi-select-container" id="linkTypeSelect">
                </div>
            </div>
            
            <div class="control-group">
                <label>佈局模式</label>
                <div class="layout-toggle">
                    <button class="layout-btn active" data-layout="force">樹狀網路圖</button>
                    <button class="layout-btn" data-layout="circle">圓形網路圖</button>
                </div>
            </div>
        </div>

        
        <div id="network-container">
            <div class="legend" id="legend">
                <div class="legend-header" onclick="toggleLegend()">
                    <h4>圖例</h4>
                    <div class="legend-toggle">↑</div>
                </div>
                <div class="legend-content" id="legend-content">
                    <!-- 圖例內容將由 JavaScript 動態生成 -->
                </div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoom-in">+</button>
                <button class="zoom-btn" id="zoom-out">−</button>
                <button class="zoom-btn" id="zoom-reset" title="重置縮放">⌂</button>
            </div>
        </div>
        </div>    
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        // 全域變數
        let currentLayout = 'force';
        let filteredNodes = [];
        let filteredLinks = [];
        let consolidatedLinks = [];
        let svg, simulation, tooltip, zoom, g;
        let fixedTooltip = null;
        let searchedNode = null;
        let suggestionsVisible = false;
        let highlightedSuggestion = -1;

        // 原始資料
        let sampleNodes = [];
        let sampleLinks = [];

        // 選中的篩選項目 - 預設為空陣列（沒有選取任何項目）
        let selectedFilters = {
            linkYear: [],
            linkType: []
        };

        // 動態顏色配置
        let nodeColors = {};
        let linkColors = {};

        // 預定義的顏色調色板
        const colorPalettes = {
            nodes: [
                "#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#feca57",
                "#ff9ff3", "#54a0ff", "#5f27cd", "#00d2d3", "#ff9f43",
                "#ee5a24", "#10ac84", "#f368e0", "#6c5ce7", "#a55eea",
                "#26de81", "#fd79a8", "#fdcb6e", "#e17055", "#74b9ff"
            ],
            links: [
                "#ff9ff3", "#54a0ff", "#5f27cd", "#00d2d3", "#ff9f43",
                "#ee5a24", "#10ac84", "#f368e0", "#6c5ce7", "#a55eea",
                "#26de81", "#fd79a8", "#fdcb6e", "#e17055", "#74b9ff",
                "#fd63a3", "#6c5ce7", "#a29bfe", "#00b894", "#e84393"
            ]
        };

        // 圖例收合功能
        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.classList.toggle('collapsed');
        }

        // 搜尋功能
        function setupSearchFunctionality() {
            const searchInput = document.getElementById('nodeSearch');
            const suggestionsContainer = document.getElementById('searchSuggestions');

            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.toLowerCase().trim();
                
                if (query.length === 0) {
                    hideSuggestions();
                    return;
                }

                const matchingNodes = sampleNodes.filter(node => 
                    node.name.toLowerCase().includes(query)
                );

                if (matchingNodes.length > 0) {
                    showSuggestions(matchingNodes, query);
                } else {
                    hideSuggestions();
                }
            });

            searchInput.addEventListener('keydown', function(e) {
                if (!suggestionsVisible) return;

                const suggestions = suggestionsContainer.querySelectorAll('.search-suggestion');
                
                switch(e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        highlightedSuggestion = Math.min(highlightedSuggestion + 1, suggestions.length - 1);
                        updateHighlight(suggestions);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        highlightedSuggestion = Math.max(highlightedSuggestion - 1, -1);
                        updateHighlight(suggestions);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (highlightedSuggestion >= 0) {
                            selectSuggestion(suggestions[highlightedSuggestion].textContent);
                        }
                        break;
                    case 'Escape':
                        hideSuggestions();
                        searchInput.blur();
                        break;
                }
            });

            searchInput.addEventListener('blur', function() {
                // 延遲隱藏建議，讓點擊建議項目有時間執行
                setTimeout(() => {
                    hideSuggestions();
                }, 200);
            });

            // 點擊搜尋框外部時隱藏建議
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    hideSuggestions();
                }
            });
        }

        function showSuggestions(nodes, query) {
            const suggestionsContainer = document.getElementById('searchSuggestions');
            suggestionsContainer.innerHTML = '';
            
            // 限制顯示的建議數量
            const maxSuggestions = 8;
            const nodesToShow = nodes.slice(0, maxSuggestions);
            
            nodesToShow.forEach((node, index) => {
                const suggestionDiv = document.createElement('div');
                suggestionDiv.className = 'search-suggestion';
                
                // 高亮匹配的部分
                const highlightedName = highlightMatch(node.name, query);
                suggestionDiv.innerHTML = `${highlightedName} <span style="color: #666; font-size: 11px;">(${node.type})</span>`;
                
                suggestionDiv.addEventListener('click', function() {
                    selectSuggestion(node.name);
                });
                
                suggestionsContainer.appendChild(suggestionDiv);
            });
            
            suggestionsContainer.style.display = 'block';
            suggestionsVisible = true;
            highlightedSuggestion = -1;
        }

        function hideSuggestions() {
            const suggestionsContainer = document.getElementById('searchSuggestions');
            suggestionsContainer.style.display = 'none';
            suggestionsVisible = false;
            highlightedSuggestion = -1;
        }

        function updateHighlight(suggestions) {
            suggestions.forEach((suggestion, index) => {
                suggestion.classList.toggle('highlighted', index === highlightedSuggestion);
            });
        }

        function highlightMatch(text, query) {
            const index = text.toLowerCase().indexOf(query.toLowerCase());
            if (index === -1) return text;
            
            return text.substring(0, index) + 
                   '<strong style="color: #667eea;">' + 
                   text.substring(index, index + query.length) + 
                   '</strong>' + 
                   text.substring(index + query.length);
        }

        function selectSuggestion(nodeName) {
            const searchInput = document.getElementById('nodeSearch');
            searchInput.value = nodeName;
            hideSuggestions();
            
            // 設置搜尋的節點
            searchedNode = nodeName;
            
            // 自動聚焦到該節點
            focusOnSearchedNode();
        }

        function focusOnSearchedNode() {
            const searchInput = document.getElementById('nodeSearch');
            const nodeName = searchInput.value.trim();
            
            if (!nodeName) {
                alert('請輸入要搜尋的節點名稱');
                return;
            }

            const targetNode = filteredNodes.find(node => 
                node.name.toLowerCase() === nodeName.toLowerCase()
            );

            if (!targetNode) {
                alert('找不到該節點，請檢查節點名稱或調整篩選條件');
                return;
            }

            searchedNode = targetNode.name;
            
            // 更新視覺化以高亮目標節點
            updateVisualization();
            
            // 將視圖中心移動到目標節點
            centerOnNode(targetNode);
        }

        function centerOnNode(targetNode) {
            if (!svg || !targetNode) return;

            const container = document.getElementById('network-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // 計算需要的變換
            const scale = 1.5; // 放大倍數
            const translateX = width / 2 - targetNode.x * scale;
            const translateY = height / 2 - targetNode.y * scale;

            // 平滑過渡到目標位置
            svg.transition()
                .duration(1000)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale));
        }

        function clearSearch() {
            const searchInput = document.getElementById('nodeSearch');
            searchInput.value = '';
            searchedNode = null;
            hideSuggestions();
            
            // 重新更新視覺化以移除高亮效果
            updateVisualization();
            
            // 重置視圖
            if (svg) {
                svg.transition()
                    .duration(500)
                    .call(zoom.transform, d3.zoomIdentity);
            }
        }

        // 合併相同from和to的連結
        function consolidateLinks(links) {
            const linkMap = new Map();
            
            links.forEach(link => {
                const key = `${link.from}-${link.to}`;
                if (linkMap.has(key)) {
                    linkMap.get(key).entries.push({
                        type: link.type,
                        year: link.year,
                        url: link.url
                    });
                } else {
                    linkMap.set(key, {
                        from: link.from,
                        to: link.to,
                        entries: [{
                            type: link.type,
                            year: link.year,
                            url: link.url
                        }]
                    });
                }
            });
            
            return Array.from(linkMap.values()).map(consolidatedLink => {
                const primaryEntry = consolidatedLink.entries[0];
                const allTypes = [...new Set(consolidatedLink.entries.map(e => e.type))];
                const allYears = [...new Set(consolidatedLink.entries.map(e => e.year))].sort((a, b) => b - a);
                
                return {
                    ...consolidatedLink,
                    type: primaryEntry.type,
                    year: primaryEntry.year,
                    url: primaryEntry.url,
                    allTypes: allTypes,
                    allYears: allYears,
                    isMultiLink: consolidatedLink.entries.length > 1,
                    linkCount: consolidatedLink.entries.length
                };
            });
        }

        // 動態生成顏色配置
        function generateColors() {
            console.log('生成動態顏色配置...');
            
            const nodeTypes = [...new Set(sampleNodes.map(node => node.type))];
            nodeColors = {};
            nodeTypes.forEach((type, index) => {
                nodeColors[type] = colorPalettes.nodes[index % colorPalettes.nodes.length];
            });

            const linkTypes = [...new Set(sampleLinks.map(link => link.type))];
            linkColors = {};
            linkTypes.forEach((type, index) => {
                linkColors[type] = colorPalettes.links[index % colorPalettes.links.length];
            });

            console.log('節點顏色配置:', nodeColors);
            console.log('連結顏色配置:', linkColors);
        }

        // 載入外部資料
        async function loadData() {
            try {
                console.log('開始載入資料...');
                
                const [nodesResponse, linksResponse] = await Promise.all([
                    fetch('./nodes.json'),
                    fetch('./links.json')
                ]);

                if (!nodesResponse.ok) {
                    throw new Error(`載入節點資料失敗: ${nodesResponse.status}`);
                }
                if (!linksResponse.ok) {
                    throw new Error(`載入連結資料失敗: ${linksResponse.status}`);
                }

                sampleNodes = await nodesResponse.json();
                sampleLinks = await linksResponse.json();

                console.log('資料載入成功:', { nodes: sampleNodes.length, links: sampleLinks.length });

                generateColors();
                init();

            } catch (error) {
                console.error('載入資料時發生錯誤:', error);
                
                console.log('使用內建範例資料...');
                sampleNodes = [
                    { name: "台北市政府", type: "政府機關" },
                    { name: "新北市政府", type: "政府機關" },
                    { name: "台積電", type: "科技公司" },
                    { name: "鴻海", type: "科技公司" },
                    { name: "台灣大學", type: "教育機構" },
                    { name: "清華大學", type: "教育機構" },
                    { name: "中研院", type: "研究機構" },
                    { name: "工研院", type: "研究機構" },
                    { name: "台北醫學大學", type: "教育機構" },
                    { name: "長庚醫院", type: "醫療機構" },
                    { name: "台大醫院", type: "醫療機構" },
                    { name: "聯發科", type: "科技公司" },
                    { name: "台達電", type: "科技公司" },
                    { name: "成功大學", type: "教育機構" },
                    { name: "高雄市政府", type: "政府機關" }
                ];

                sampleLinks = [
                    { from: "台北市政府", to: "台灣大學", type: "合作協議", year: 2023, url: "https://example.com/agreement1" },
                    { from: "台北市政府", to: "台灣大學", type: "研究資助", year: 2022, url: "https://example.com/funding1" },
                    { from: "台積電", to: "清華大學", type: "產學合作", year: 2022, url: "https://example.com/cooperation1" },
                    { from: "台積電", to: "清華大學", type: "人才培育", year: 2023, url: "https://example.com/talent2" },
                    { from: "鴻海", to: "工研院", type: "技術轉移", year: 2022, url: "https://example.com/tech-transfer1" },
                    { from: "中研院", to: "台灣大學", type: "學術交流", year: 2021, url: "https://example.com/academic1" },
                    { from: "新北市政府", to: "台北醫學大學", type: "政策合作", year: 2023, url: "https://example.com/policy1" },
                    { from: "長庚醫院", to: "台大醫院", type: "醫療聯盟", year: 2023, url: "https://example.com/medical1" },
                    { from: "長庚醫院", to: "台大醫院", type: "設備共享", year: 2022, url: "https://example.com/equipment1" },
                    { from: "聯發科", to: "成功大學", type: "產學合作", year: 2023, url: "https://example.com/cooperation2" },
                    { from: "台達電", to: "清華大學", type: "研發合作", year: 2022, url: "https://example.com/rd1" },
                    { from: "高雄市政府", to: "成功大學", type: "區域發展", year: 2021, url: "https://example.com/regional1" },
                    { from: "工研院", to: "台積電", type: "技術諮詢", year: 2020, url: "https://example.com/consulting1" },
                    { from: "台灣大學", to: "台大醫院", type: "附屬關係", year: 2021, url: "https://example.com/affiliation1" },
                    { from: "中研院", to: "清華大學", type: "人才交流", year: 2020, url: "https://example.com/talent1" },
                    { from: "鴻海", to: "聯發科", type: "供應鏈", year: 2022, url: "https://example.com/supply1" },
                    { from: "台北市政府", to: "新北市政府", type: "跨域合作", year: 2023, url: "https://example.com/cross-region1" },
                    { from: "台北醫學大學", to: "長庚醫院", type: "實習合作", year: 2022, url: "https://example.com/internship1" }
                ];

                generateColors();
                init();
            }
        }

        // 初始化
        function init() {
            setupMultiSelectors();
            setupEventListeners();
            setupZoomControls();
            setupSearchFunctionality();
            createVisualization(); // 先創建視覺化元素
            filterData(); // 然後進行篩選
            updateLegend();
        }

        // 設置多選選擇器 - 修改為預設未選取
        function setupMultiSelectors() {
            const linkYears = [...new Set(sampleLinks.map(d => d.year))].sort((a, b) => b - a);
            const linkTypes = [...new Set(sampleLinks.map(d => d.type))];

            // 初始化所有項目為未選中狀態
            selectedFilters.linkYear = [];
            selectedFilters.linkType = [];

            createMultiSelect('linkYearSelect', linkYears, 'linkYear');
            createMultiSelect('linkTypeSelect', linkTypes, 'linkType');
        }

        function createMultiSelect(containerId, options, filterType) {
            const container = document.getElementById(containerId);
            
            options.forEach(option => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${filterType}_${option}`;
                checkbox.value = option;
                checkbox.checked = false; // 預設為未選取
                checkbox.addEventListener('change', () => updateFilter(filterType, option, checkbox.checked));
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = option;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                container.appendChild(item);
            });
        }

        function updateFilter(filterType, value, isChecked) {
            if (isChecked) {
                if (!selectedFilters[filterType].includes(value)) {
                    selectedFilters[filterType].push(value);
                }
            } else {
                selectedFilters[filterType] = selectedFilters[filterType].filter(item => item !== value);
            }
            filterData();
        }

        function toggleSelectAll(filterType) {
            const container = document.getElementById(`${filterType}Select`);
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = !allChecked;
                updateFilter(filterType, checkbox.value, checkbox.checked);
            });
        }

        // 設置事件監聽器
        function setupEventListeners() {
            document.querySelectorAll('.layout-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentLayout = e.target.dataset.layout;
                    updateVisualization();
                });
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.link') && !e.target.closest('.tooltip') && !e.target.closest('.tooltip-link')) {
                    hideFixedTooltip();
                }
            });
        }

        // 設置縮放控制
        function setupZoomControls() {
            document.getElementById('zoom-in').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1.5);
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            });

            document.getElementById('zoom-reset').addEventListener('click', () => {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });
        }

        // 篩選資料 - 根據年份和連結類型篩選
        function filterData() {
            // 先篩選連結
            filteredLinks = sampleLinks.filter(link => {
                return (selectedFilters.linkYear.length === 0 || selectedFilters.linkYear.includes(link.year)) &&
                       (selectedFilters.linkType.length === 0 || selectedFilters.linkType.includes(link.type));
            });

            // 根據篩選後的連結決定顯示哪些節點
            const nodeNames = new Set();
            filteredLinks.forEach(link => {
                nodeNames.add(link.from);
                nodeNames.add(link.to);
            });

            filteredNodes = sampleNodes.filter(node => nodeNames.has(node.name));

            consolidatedLinks = consolidateLinks(filteredLinks);

            // 只有在視覺化元素已經創建後才更新
            if (g) {
                updateVisualization();
            }
            if (document.getElementById('legend')) {
                updateLegend();
            }
        }

        // 創建視覺化
        function createVisualization() {
            const container = document.getElementById('network-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            console.log('Creating visualization:', width, height);
            console.log('Filtered nodes:', filteredNodes.length);
            console.log('Filtered links:', filteredLinks.length);
            console.log('Consolidated links:', consolidatedLinks.length);

            d3.select('#network-container svg').remove();

            svg = d3.select('#network-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#f8f9fa');

            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            g = svg.append('g');

            tooltip = d3.select('#tooltip');

            updateVisualization();
        }

        // 獲取與目標節點相關的連結
        function getRelatedLinks(targetNodeName) {
            return consolidatedLinks.filter(link => 
                link.from === targetNodeName || link.to === targetNodeName
            );
        }

        // 獲取與目標節點相連的節點
        function getConnectedNodes(targetNodeName) {
            const connectedNodeNames = new Set();
            const relatedLinks = getRelatedLinks(targetNodeName);
            
            relatedLinks.forEach(link => {
                connectedNodeNames.add(link.from);
                connectedNodeNames.add(link.to);
            });
            
            return filteredNodes.filter(node => 
                connectedNodeNames.has(node.name)
            );
        }

        // 更新視覺化
        function updateVisualization() {
            if (!g) return; // 如果 g 還沒初始化，就直接返回
            
            const container = document.getElementById('network-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            console.log('Updating visualization:', currentLayout);
            console.log('Container size:', width, height);

            g.selectAll("*").remove();

            if (filteredNodes.length === 0) {
                g.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '18px')
                    .attr('fill', '#666')
                    .text('請選擇年份和連結類型以顯示資料');
                return;
            }

            consolidatedLinks = consolidateLinks(filteredLinks);

            if (currentLayout === 'force') {
                createForceLayout(width, height);
            } else {
                createCircleLayout(width, height);
            }
        }

        // Force布局
        function createForceLayout(width, height) {
            const linkData = consolidatedLinks.map(d => ({
                source: d.from,
                target: d.to,
                type: d.type,
                year: d.year,
                url: d.url,
                from: d.from,
                to: d.to,
                entries: d.entries,
                allTypes: d.allTypes,
                allYears: d.allYears,
                isMultiLink: d.isMultiLink,
                linkCount: d.linkCount
            }));

            simulation = d3.forceSimulation(filteredNodes)
                .force('link', d3.forceLink(linkData).id(d => d.name).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // 如果有搜尋的節點，獲取相關的連結和節點
            let relatedLinks = [];
            let connectedNodes = [];
            if (searchedNode) {
                relatedLinks = getRelatedLinks(searchedNode);
                connectedNodes = getConnectedNodes(searchedNode);
            }

            const link = g.append('g')
                .selectAll('line')
                .data(linkData)
                .enter().append('line')
                .attr('class', d => {
                    let classes = `link ${d.isMultiLink ? 'multi-link' : ''}`;
                    if (searchedNode && !relatedLinks.some(rl => 
                        rl.from === d.from && rl.to === d.to)) {
                        classes += ' dimmed';
                    }
                    return classes;
                })
                .attr('stroke', d => linkColors[d.type] || '#999')
                .attr('stroke-width', d => d.isMultiLink ? 3 : 2)
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', function(event, d) {
                    event.stopPropagation();
                    showFixedTooltip(event, d);
                });

            const node = g.append('g')
                .selectAll('circle')
                .data(filteredNodes)
                .enter().append('circle')
                .attr('class', d => {
                    let classes = 'node';
                    if (searchedNode) {
                        if (d.name === searchedNode) {
                            classes += ' focused';
                        } else if (!connectedNodes.some(cn => cn.name === d.name)) {
                            classes += ' dimmed';
                        }
                    }
                    return classes;
                })
                .attr('r', d => d.name === searchedNode ? 25 : 20)
                .attr('fill', d => nodeColors[d.type] || '#999')
                .on('mouseover', function(event, d) {
                    tooltip
                        .style('display', 'block')
                        .html(`
                            <h4>節點資訊</h4>
                            <p><strong>名稱:</strong> ${d.name}</p>
                            <p><strong>類型:</strong> ${d.type}</p>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    if (!fixedTooltip) {
                        tooltip.style('display', 'none');
                    }
                })
                .on('click', function(event, d) {
                    // 點擊節點時將其設為搜尋目標
                    searchedNode = d.name;
                    document.getElementById('nodeSearch').value = d.name;
                    updateVisualization();
                    centerOnNode(d);
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            const nodeText = g.append('g')
                .selectAll('text')
                .data(filteredNodes)
                .enter().append('text')
                .attr('class', d => {
                    let classes = 'node-text';
                    if (searchedNode && d.name !== searchedNode && 
                        !connectedNodes.some(cn => cn.name === d.name)) {
                        classes += ' dimmed';
                    }
                    return classes;
                })
                .text(d => d.name)
                .style('pointer-events', 'none')
                .style('font-size', d => d.name === searchedNode ? '12px' : '11px')
                .style('font-weight', d => d.name === searchedNode ? 'bold' : '600');

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                nodeText
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        // Circle布局
        function createCircleLayout(width, height) {
            const radius = Math.min(width, height) / 2 - 50;
            const center = { x: width / 2, y: height / 2 };

            // 如果有搜尋的節點，將其放在中心
            let nodePositions;
            if (searchedNode) {
                const targetNodeIndex = filteredNodes.findIndex(node => node.name === searchedNode);
                const connectedNodes = getConnectedNodes(searchedNode);
                
                nodePositions = filteredNodes.map((node, i) => {
                    if (node.name === searchedNode) {
                        return {
                            ...node,
                            x: center.x,
                            y: center.y
                        };
                    } else if (connectedNodes.some(cn => cn.name === node.name)) {
                        // 相連的節點圍繞在目標節點周圍
                        const connectedIndex = connectedNodes.findIndex(cn => cn.name === node.name);
                        const angle = (connectedIndex / (connectedNodes.length - 1)) * 2 * Math.PI;
                        const nodeRadius = radius * 0.6;
                        return {
                            ...node,
                            x: center.x + nodeRadius * Math.cos(angle),
                            y: center.y + nodeRadius * Math.sin(angle)
                        };
                    } else {
                        // 其他節點放在外圈
                        const otherNodes = filteredNodes.filter(n => 
                            n.name !== searchedNode && 
                            !connectedNodes.some(cn => cn.name === n.name)
                        );
                        const otherIndex = otherNodes.findIndex(n => n.name === node.name);
                        const angle = (otherIndex / otherNodes.length) * 2 * Math.PI;
                        return {
                            ...node,
                            x: center.x + radius * Math.cos(angle),
                            y: center.y + radius * Math.sin(angle)
                        };
                    }
                });
            } else {
                nodePositions = filteredNodes.map((node, i) => {
                    const angle = (i / filteredNodes.length) * 2 * Math.PI;
                    return {
                        ...node,
                        x: center.x + radius * Math.cos(angle),
                        y: center.y + radius * Math.sin(angle)
                    };
                });
            }

            const linkData = consolidatedLinks.map(d => {
                const sourceNode = nodePositions.find(n => n.name === d.from);
                const targetNode = nodePositions.find(n => n.name === d.to);
                return {
                    ...d,
                    source: sourceNode,
                    target: targetNode,
                    x1: sourceNode ? sourceNode.x : 0,
                    y1: sourceNode ? sourceNode.y : 0,
                    x2: targetNode ? targetNode.x : 0,
                    y2: targetNode ? targetNode.y : 0
                };
            }).filter(d => d.source && d.target);

            // 獲取相關連結（如果有搜尋節點）
            let relatedLinks = [];
            let connectedNodes = [];
            if (searchedNode) {
                relatedLinks = getRelatedLinks(searchedNode);
                connectedNodes = getConnectedNodes(searchedNode);
            }

            const link = g.append('g')
                .selectAll('line')
                .data(linkData)
                .enter().append('line')
                .attr('class', d => {
                    let classes = `link ${d.isMultiLink ? 'multi-link' : ''}`;
                    if (searchedNode && !relatedLinks.some(rl => 
                        rl.from === d.from && rl.to === d.to)) {
                        classes += ' dimmed';
                    }
                    return classes;
                })
                .attr('stroke', d => linkColors[d.type] || '#999')
                .attr('stroke-width', d => d.isMultiLink ? 3 : 2)
                .attr('x1', d => d.x1)
                .attr('y1', d => d.y1)
                .attr('x2', d => d.x2)
                .attr('y2', d => d.y2)
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', function(event, d) {
                    event.stopPropagation();
                    showFixedTooltip(event, d);
                });

            const node = g.append('g')
                .selectAll('circle')
                .data(nodePositions)
                .enter().append('circle')
                .attr('class', d => {
                    let classes = 'node';
                    if (searchedNode) {
                        if (d.name === searchedNode) {
                            classes += ' focused';
                        } else if (!connectedNodes.some(cn => cn.name === d.name)) {
                            classes += ' dimmed';
                        }
                    }
                    return classes;
                })
                .attr('r', d => d.name === searchedNode ? 25 : 20)
                .attr('fill', d => nodeColors[d.type] || '#999')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .on('mouseover', function(event, d) {
                    tooltip
                        .style('display', 'block')
                        .html(`
                            <h4>節點資訊</h4>
                            <p><strong>名稱:</strong> ${d.name}</p>
                            <p><strong>類型:</strong> ${d.type}</p>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    if (!fixedTooltip) {
                        tooltip.style('display', 'none');
                    }
                })
                .on('click', function(event, d) {
                    // 點擊節點時將其設為搜尋目標
                    searchedNode = d.name;
                    document.getElementById('nodeSearch').value = d.name;
                    updateVisualization();
                    centerOnNode(d);
                });

            const nodeText = g.append('g')
                .selectAll('text')
                .data(nodePositions)
                .enter().append('text')
                .attr('class', d => {
                    let classes = 'node-text';
                    if (searchedNode && d.name !== searchedNode && 
                        !connectedNodes.some(cn => cn.name === d.name)) {
                        classes += ' dimmed';
                    }
                    return classes;
                })
                .text(d => d.name)
                .attr('x', d => d.x)
                .attr('y', d => d.y)
                .style('pointer-events', 'none')
                .style('font-size', d => d.name === searchedNode ? '12px' : '11px')
                .style('font-weight', d => d.name === searchedNode ? 'bold' : '600');
        }

        // Tooltip functions
        function showTooltip(event, d) {
            if (fixedTooltip) return;
            
            let tooltipHTML = `<h4>連結資訊</h4>`;
            tooltipHTML += `<p><strong>起點:</strong> ${d.from}</p>`;
            tooltipHTML += `<p><strong>終點:</strong> ${d.to}</p>`;
            
            if (d.isMultiLink) {
                tooltipHTML += `<p><strong>連結數量:</strong> ${d.linkCount}</p>`;
                tooltipHTML += `<div style="margin-top: 10px;">`;
                d.entries.forEach((entry, index) => {
                    tooltipHTML += `
                        <div class="link-entry">
                            <p><strong>類型 ${index + 1}:</strong> ${entry.type}</p>
                            <p><strong>年份:</strong> ${entry.year}</p>
                            <p><strong>參考:</strong> <a href="${entry.url}" target="_blank" rel="noopener noreferrer">查看詳情</a></p>
                        </div>
                    `;
                });
                tooltipHTML += `</div>`;
            } else {
                tooltipHTML += `<p><strong>類型:</strong> ${d.type}</p>`;
                tooltipHTML += `<p><strong>年份:</strong> ${d.year}</p>`;
                tooltipHTML += `<p><strong>參考:</strong> <a href="${d.url}" target="_blank" rel="noopener noreferrer">查看詳情</a></p>`;
            }
            
            tooltip
                .style('display', 'block')
                .html(tooltipHTML)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        }

        function hideTooltip() {
            if (!fixedTooltip && tooltip) { // 檢查 tooltip 是否存在
                tooltip.style('display', 'none');
            }
        }

        function showFixedTooltip(event, d) {
            fixedTooltip = d;
            
            let tooltipHTML = `<h4>連結資訊 (點擊空白處關閉)</h4>`;
            tooltipHTML += `<p><strong>起點:</strong> ${d.from}</p>`;
            tooltipHTML += `<p><strong>終點:</strong> ${d.to}</p>`;
            
            if (d.isMultiLink) {
                tooltipHTML += `<p><strong>連結數量:</strong> ${d.linkCount}</p>`;
                tooltipHTML += `<div style="margin-top: 10px;">`;
                d.entries.forEach((entry, index) => {
                    tooltipHTML += `
                        <div class="link-entry">
                            <p><strong>類型 ${index + 1}:</strong> ${entry.type}</p>
                            <p><strong>年份:</strong> ${entry.year}</p>
                            <p><strong>參考:</strong> <a href="${entry.url}" target="_blank" rel="noopener noreferrer" class="tooltip-link">查看詳情</a></p>
                        </div>
                    `;
                });
                tooltipHTML += `</div>`;
            } else {
                tooltipHTML += `<p><strong>類型:</strong> ${d.type}</p>`;
                tooltipHTML += `<p><strong>年份:</strong> ${d.year}</p>`;
                tooltipHTML += `<p><strong>參考:</strong> <a href="${d.url}" target="_blank" rel="noopener noreferrer" class="tooltip-link">查看詳情</a></p>`;
            }
            
            tooltip
                .style('display', 'block')
                .html(tooltipHTML)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
                
            setTimeout(() => {
                const links = tooltip.selectAll('.tooltip-link').nodes();
                links.forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.stopPropagation();
                        window.open(this.href, '_blank', 'noopener,noreferrer');
                    });
                });
            }, 0);
        }

        function hideFixedTooltip() {
            fixedTooltip = null;
            if (tooltip) { // 檢查 tooltip 是否存在
                tooltip.style('display', 'none');
            }
        }

        // 拖拽功能
        function dragstarted(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active && simulation) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 更新圖例
        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            
            let legendHTML = '';

            // 節點類型區塊
            const visibleNodeTypes = [...new Set(filteredNodes.map(node => node.type))];
            if (visibleNodeTypes.length > 0) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>節點類型</h5>';
                visibleNodeTypes.forEach(type => {
                    const color = nodeColors[type] || '#999';
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: ${color}"></div>
                            <span>${type}</span>
                        </div>
                    `;
                });
                legendHTML += '</div>';
            }

            // 連結類型區塊
            const visibleLinkTypes = [...new Set(filteredLinks.map(link => link.type))];
            if (visibleLinkTypes.length > 0) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>連結類型</h5>';
                visibleLinkTypes.forEach(type => {
                    const color = linkColors[type] || '#999';
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-line" style="background-color: ${color};"></div>
                            <span>${type}</span>
                        </div>
                    `;
                });
                legendHTML += '</div>';
            }

            // 連結樣式區塊
            if (consolidatedLinks.some(link => link.isMultiLink)) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>連結樣式</h5>';
                legendHTML += `
                    <div class="legend-item">
                        <div class="legend-dashed"></div>
                        <span>多重連結</span>
                    </div>
                `;
                legendHTML += '</div>';
            }

            // 搜尋狀態說明
            if (searchedNode) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>搜尋狀態</h5>';
                legendHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #667eea; border: 2px solid #667eea;"></div>
                        <span>聚焦節點</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ccc; opacity: 0.5;"></div>
                        <span>非相關節點</span>
                    </div>
                `;
                legendHTML += '</div>';
            }

            legendContent.innerHTML = legendHTML;
        }

        // 視窗大小改變時重新繪製
        window.addEventListener('resize', () => {
            setTimeout(createVisualization, 100);
        });

        // 啟動應用程式
        loadData();
    </script>
</body>
</html>